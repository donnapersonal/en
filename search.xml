<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>script 标签的 defer 与 async</title>
      <link href="/2021/04/15/script-defer-async/"/>
      <url>/2021/04/15/script-defer-async/</url>
      
        <content type="html"><![CDATA[<p><img src="script.png" alt="script 标签"></p><h1 id="普通-script-标签"><a href="#普通-script-标签" class="headerlink" title="普通 script 标签"></a>普通 script 标签</h1><p><code>JS</code> 可能会修改 <code>HTML</code> 和 <code>CSS</code>，因此 <code>JS</code> 的下载执行过程不能和 <code>HTML/CSS</code> 并行</p><p>代码执行过程：</p><ul><li><code>HTML</code> 解析过程中若碰到外联的 <code>JS</code> 会暂时中止 <code>HTML</code> 的解析流程</li><li>等待脚本下载和解析完成后再继续进行之前中断掉的 <code>HTML</code> 解析流程</li></ul><p>因此，<code>script</code> 标签外联 <code>JS</code> 加载有这样的缺点：</p><ul><li><strong>会影响整个页面效率，一旦网速不好整个网站将等待 <code>JS</code> 加载而不进行后续渲染</strong></li><li><strong>由于中断了 <code>HTML</code> 解析流程，所以会导致页面空白等，影响体验</strong></li></ul><blockquote><p>早前，常用的写法是将 <code>script</code> 标签写在 <code>body</code> 最后面，等 <code>DOM</code> 全部解析完成后才加载 <code>JS</code>，但 <code>HTML5</code> 标准有另一套异步加载 <code>JS</code> 的方法（<code>defer</code> &#x2F; <code>async</code>）</p></blockquote><h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>在 <code>script</code> 标签的行间写一个 <code>defer=“defer”</code> 或直接写 <code>defer</code> 就可让这个 <code>script</code> 外联的 <code>JS</code> 变成异步加载</p><p>代码执行过程：</p><ul><li><code>HTML</code> 解析流程中若碰到外联 <code>JS</code> 时会开辟新线程来下载脚本，下载完成后不会立即解析，因此不会阻塞 <code>HTML</code> 的解析流程</li><li>等到 <code>HTML</code> 解析完毕后（不包括下载完里面的资源），<code>DOMContentLoaded</code> 事件调用前再进行相应脚本的执行解析</li><li>注意：<code>DOMContentLoaded</code> 事件会等待 <code>defer</code> 的脚本执行完后才触发</li></ul><blockquote><p>注意：</p><ul><li>这种方式可同时在 <code>script</code> 闭合标签间写代码</li><li>该方法只有 <code>IE</code> 和一些高版本的 <code>firefox</code> 和 <code>chrome</code> 可以用</li><li><code>IE6</code> 和 <code>IE7</code> 的异步加载最多只能有 <code>2</code> 个，超过两个时必须等前两个加载完才会加载第三个</li><li><strong>所有 <code>defer</code> 的 <code>JS</code> 代码都保证按照顺序执行</strong></li></ul></blockquote><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p><code>async</code> 是 <code>asynchronous</code> 的缩写，是 <code>HTML5</code> 标准</p><p>代码执行过程：</p><ul><li><code>HTML</code> 解析流程中若碰到外联 <code>JS</code> 时会开辟新线程来下载脚本，下载完成后立即解析执行，且解析流程会中断 <code>HTML</code> 解析流程</li><li>等到脚本执行完成后才会继续进行之前中断掉的 <code>HTML</code> 解析流程</li></ul><blockquote><p>注意：</p><ul><li>这种方法除了 <code>IE6 ～ IE8</code> 其他的浏览器都好用</li><li>该方式不能把代码写在 <code>script</code> 闭合标签里，只能引用外部脚本（虽然标准是这么写的，但现在随着内核升级，<code>async</code> 的 <code>script</code> 标签里也可写代码，在没有 <code>src</code> 情况下）</li><li><strong><code>async</code> 的 <code>JS</code> 代码不能保证是顺序执行的，而是按照 <code>race</code> 的方式哪个脚本先下载完就先解析哪个脚本</strong></li></ul></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong><code>defer</code> 和 <code>async</code> 这两个属性不能一起使用</strong>，若同时使用 <code>async</code> 和 <code>defer</code> 属性，<code>defer</code> 不起作用，浏览器行为由 <code>async</code> 属性决定</p><h1 id="兼容性写法"><a href="#兼容性写法" class="headerlink" title="兼容性写法"></a>兼容性写法</h1><p>暴力写法：直接写两个 <code>script</code> 标签，一个采用 <code>defer</code> 一个采用 <code>async</code>。这种方法的缺陷：</p><ul><li><code>IE</code> 高版本会加载两遍从而引起冲突</li><li>但有些浏览器两个都没有从而一个都加载不出来</li></ul><p>优化写法：<strong>通过动态添加 <code>script</code> 标签，<code>W3C</code> 的标准规定动态添加的 <code>script</code> 标签是异步的</strong></p><p>这里 <code>src</code> 部分的下载是异步的，不会阻塞后面代码的执行，即可一边把 <code>script</code> 插入到 <code>DOM</code> 中一边下载资源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要注意的是 readyState 的 if-else 一定要写在 script.src = url 和 appendChild 之前</span></span><br><span class="line"><span class="comment">// 因电脑速度可能会很快，刚走到 src = url 部分就已经加载完毕了, 此时 readyState 已变成 loaded，后面就不会触发 onreadystatechange 事件</span></span><br><span class="line"><span class="comment">// 若回调函数是写在需要加载进来的文件里的方法，需要把该方法放到匿名函数里，这样在语法解析时才不会因为函数未声明而报错，确保脚本加载完成后再执行这些方法</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">    script.<span class="property">type</span> = <span class="string">&quot;text/javascript&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (script.<span class="property">readyState</span>) &#123; <span class="comment">// IE 和高版本的 chrome、firefox</span></span><br><span class="line">      script.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (script.<span class="property">readeyState</span> === <span class="string">&quot;loaded&quot;</span> || script.<span class="property">readeyState</span> === <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">          script.<span class="property">onreadystatechange</span> = <span class="literal">null</span>;</span><br><span class="line">          callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      script.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// safari chrome opera firefox</span></span><br><span class="line">        callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.<span class="property">src</span> = url;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
